#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/df7f7699-04ca-4290-821a-e54a4cd91f12

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String message;
  float i;
  float kWh;
  float p;
  float sensorValueA0;
  float v;
  float voltageA0;
  float voltageA1;
  CloudLight alto;
  CloudLight baixo;
  CloudLight emergencia;
  CloudLight estufaaberta;
  CloudLight estufafechada;
  CloudLight ligatudo;
  int contador;
  int contador2;
  CloudLocation teste1;
  CloudSchedule programador1;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <ArduinoModbus.h>
#include <ArduinoRS485.h>
constexpr auto baudrate { 19200 }; 
constexpr auto btime { 1.0f / baudrate };
constexpr auto predl { btime * 9.6f * 3.5f * 1e6 };
constexpr auto postdl { btime * 9.6f * 3.5f * 1e6 };
bool conmuta2 = true;      //variável começa em sinal true ou 1
bool conmuta = true;      //variável começa em sinal true ou 1
int entrada1 = A0;         //Nome entrada digital OPTA
int estadoentrada1 = 0;    //Variável que armazena o valor da entrada1
int entrada2 = A1;        //Nome entrada digital OPTA
int estadoentrada2 = 0;   //Variável que armazena o valor da entrada2
#define entrada A2        //Nome entrada digital OPTA
float estadoentrada3 = 0; //Variável que armazena o valor da entrada3
int entrada4 = A4;
int estadoentrada4 = 0;
float teste = 0;
float volteste = 0;

void setup() {

  Serial.begin(115200);     //inicialização da comunicação serial
  delay(2000);            //Aguarda 1,5 após a inicialização serial
  
  RS485.setDelays(predl, postdl);
  if (!ModbusRTUClient.begin(baudrate, SERIAL_8N2 ) ) {
    Serial.println("errore modbus");
    while(1);
  }
  
  pinMode(D2, OUTPUT);         //Definição da saída do OPTA
  pinMode(D0, OUTPUT);         //Definição da saída do OPTA
  pinMode(entrada1, INPUT);    //Definição da entrada do OPTA


  pinMode(D1, OUTPUT);         //Definição da saída do OPTA
  pinMode(entrada2, INPUT);    //Definição da entrada do OPTA
  pinMode(entrada4, INPUT);

  pinMode(entrada, INPUT);     //Definição da entrada do OPTA
  kWh = 0;                     //Variável kWh que sempre inicia com a contagem em 0
  contador = 0;                //Variável contador que sempre inicia com a contagem em 0
  contador2 = 0;               //Variável contador2 que sempre inicia com a contagem em 0
  initProperties();
  analogReadResolution(12);

  ArduinoCloud.begin(ArduinoIoTPreferredConnection);


  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  
  //0x09BA - Active Power Total 32490-32491, IEEE 754 T_Float, x 1W
  p = readdata(0x21, 0x9E4);
  //0x09C4 - Tensione 32500-32501, IEEE 754 T_Float, x 
  v = readdata(0x21, 0x9C6);
  // 0x9D4 - corrente 32516-32517, IEEE 754 T_Float, x 1A
  i = readdata(0x21, 0x9D6);

  Serial.println(String(p, 1) + "W " + String(v, 1) + "V " + String(i, 3) + "A ");
  delay(50);
  
  double Lat;                               //definição de latitude
  double Long;                              //definição de longitude

  teste1 = {-23.62141, -46.57541};          //coordenadas de latitude e longitude

  sensorValueA0 = analogRead(A3);
  voltageA0 = sensorValueA0 * (3.0 / 4095.0) / 0.3 * 10;
  teste = sensorValueA0 * (3.0 / 4095.0) / 0.3;
  volteste = teste - 1.79;
  voltageA1 = (volteste*1000)/7;
  delay(5);

  estadoentrada3 = digitalRead(entrada);  //a variável estadoentrada3 está lendo a porta "entrada"
  if (estadoentrada3 == HIGH) {           //caso o estadoentrada3 for HIGH
    kWh = kWh + 0.002;                      //soma na variável kWh 0.002
    Serial.println(kWh);                    //Imprime o valor no monitor serial
    delay(100);                             //aguarda 100ms
  }

  estadoentrada4 = digitalRead(entrada4);
  if (estadoentrada4 == HIGH) {
    message = "PORTA FECHADA";
    estufaaberta = LOW;
    estufafechada = HIGH;
  } else {
    message = "PORTA ABERTA";
    estufafechada = LOW;
    estufaaberta = HIGH;
  }



  if (programador1.isActive()) {             //se o programador horário estiver ativo

    estadoentrada1 = digitalRead(entrada1);  //a variável estadoentrada1 está lendo a porta entrada1
    if (estadoentrada1 == HIGH) {             //caso o estadoentrada1 for HIGH
      delay(5);                             //aguarda 500ms para terminar o bounce do contato
      digitalWrite(D0, HIGH);                 // ativa a saída do OPTA D0
      alto = HIGH;                            // coloca o led de sinalização do dashboard para HIGH
      if (conmuta) {                           // se todas as funções acima acontecer consute a variável conmuta
        contador++;                           //incremente um valor no contador
        conmuta = false;                      //depois retorna a variável conmuta para false para garantir somente uma contagem
      }
    }
    else {
      digitalWrite(D0, LOW);                  //se nada acontecer no código acima deixar a saída do OPTA D0 em LOW
      alto = LOW;                             //coloca o led de sinalização do dashboard para LOW
      conmuta = true;                         //deixa a váriavel conmuta em true
    }


    estadoentrada2 = digitalRead(entrada2);   //a variável estadoentrada3 está lendo a porta entrada2
    if (estadoentrada2 == HIGH) {             //caso o estadoentrada2 for HIGH
      delay(5);                             //aguarda 500ms para terminar o bounce do contato
      digitalWrite(D1, HIGH);                 // ativa a saída do OPTA D1
      baixo = HIGH;                           // coloca o led de sinalização do dashboard para HIGH
      if (conmuta2) {                         // se todas as funções acima acontecer consute a variável conmuta2
        contador2++;                          //incremente um valor no contador2
        conmuta2 = false;                     //depois retorna a variável conmuta para false para garantir somente uma contagem
      }
    }
    else {
      digitalWrite(D1, LOW);                  //se nada acontecer no código acima deixar a saída do OPTA D1 em LOW
      baixo = LOW;                            //coloca o led de sinalização do dashboard para LOW
      conmuta2 = true;                        //depois retorna a variável conmuta para false para garantir somente uma contagem
    }

  } else {
    digitalWrite(D0, LOW);                    //se o programador horário não estiver ativo, D0 fica em LOW
    digitalWrite(D1, LOW);                    //se o programador horário não estiver ativo, D1 fica em LOW
    digitalWrite(D2, LOW);                    //se o programador horário não estiver ativo, D2 fica em LOW
  }


}

void onBaixoChange()  {

}

void onAltoChange()  {

}

void onEmergenciaChange()  {
  if (emergencia == 1) {
    digitalWrite(D2, HIGH);
  } else {
    digitalWrite(D2, LOW);
  }
}

float readdata(int addr, int reg) {
  float res = 0.0;
  if (!ModbusRTUClient.requestFrom(addr, INPUT_REGISTERS, reg, 2)) {
    Serial.println("errore com");
    Serial.println(ModbusRTUClient.lastError());
  } else {
    uint16_t word1 = ModbusRTUClient.read();
    uint16_t word2 = ModbusRTUClient.read();
    uint32_t parz = word1 << 16 | word2;
    res = *(float *)&parz;
  }
  return res;
}

void onLigatudoChange()  {

}

void onLedEstadoChange()  {

}

void onProgramadorChange()  {

}

void onProgramador1Change()  {

}

void onContador2Change()  {

}






/*
  Since Message is READ_WRITE variable, onMessageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMessageChange()  {
  // Add your code here to act upon Message change
}












